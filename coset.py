# Find quotient group (Z/mZ)*/<p>
# the list of cosets is displayed in sorted order if isSort=1  
#!/usr/bin/python
from fractions import gcd

isSort=0
m=257
p=2
cg_p=[]
zmStar=[]

# <p>
cg_p.append(1) 
for a in range(1,m):
    b=(p**a)%m
    if  b == 1:
        break

    cg_p.append(b) 
if isSort==1:
    cg_p.sort()
print("** cyclic group generated by "+str(p)+" mod "+str(m)+ " **")
print("  <"+str(p)+">=",end="")
print(cg_p)
print("  with order ="+str(len(cg_p)) )
print()

# (Z/mZ)*
for a in range(1,m):
    if(gcd(a,m)==1):
        zmStar.append(a)
print("** multiplicative group (Z/"+str(m)+"Z)*   **")
print("  (Z/"+str(m)+"/Z)*=",end="")
print(zmStar)
print(str(len(zmStar)))


# find coset
# filtering perspective:
# 1) element in coset must be in (Z/mZ)*
# 2) a generated coset must not be in the previously generated set of cosets
coset=[]
mat_coset=[]
#idx=0;
mat_coset.append(cg_p)
for a in zmStar:
    for b in cg_p:
        c=(a*b)%m
        coset.append(c)
    # 1) if element in coset is not in zmStar, skip the current itr.
    for bb in coset:
        if not (bb in zmStar):
            coset=[]
            break;
    if len(coset)==0:
        continue

    # if not filtered out by 1)
    # 2) check if element already exists in previous generated cosets 
    # coset is generated if its order is same as <p> 
    if isSort==1:
        coset.sort()
    if len(coset) == len(cg_p):
        isNewCoset=1
        # if the coset is new, append it to coset matrix
        for prev_coset in mat_coset:
            for c in coset:
                if c in prev_coset:
                    isNewCoset = 0

        if isNewCoset == 1 :
           mat_coset.append(coset)
#           idx=idx+1
    coset=[]
print("\n")
print("** The quotrient group (Z/mZ)*/<p>=(Z/"+str(m)+"Z)*/<"+str(p)+"> **")
print("** consists of "+str(len(mat_coset))+" cosets **")
for cset in mat_coset:
    print(cset)
